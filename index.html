<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Environment with Improved Collision</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: black;
            font-family: Arial, sans-serif;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="instructions">
    Нажмите, чтобы начать
</div>

<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

    // Основные элементы сцены
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Свет
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);

    // Плоскость (пол)
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x008000 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Куб
    const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
    const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube.position.set(5, 1, 5);
    scene.add(cube);

    // Другие блоки
    const blocks = [cube];

    // Добавляем несколько блоков
    for (let i = 0; i < 5; i++) {
        const block = new THREE.Mesh(
            new THREE.BoxGeometry(2, 2, 2),
            new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
        );
        block.position.set(Math.random() * 20 - 10, 1, Math.random() * 20 - 10);
        scene.add(block);
        blocks.push(block);
    }

    // Оболочка для управления камерой
    const cameraWrapper = new THREE.Object3D();
    cameraWrapper.add(camera);
    scene.add(cameraWrapper);

    // Добавление маленького кубика-оружия
    const weaponGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
    const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
    weapon.position.set(0.5, -0.5, -1); // Смещение относительно камеры
    camera.add(weapon); // Прикрепляем кубик к камере

    // Переменные для управления
    const speed = 5; // Скорость передвижения
    const gravity = 9.8; // Гравитация
    const jumpStrength = 5; // Сила прыжка
    const movement = { forward: false, backward: false, left: false, right: false };
    let velocityY = 0; // Вертикальная скорость
    const playerHeight = 1.5;
    let isGrounded = true;

    // Позиция камеры
    camera.position.set(0, playerHeight, 0);

    // Функция проверки столкновений
    function checkCollisions(position, direction) {
        const playerBounds = new THREE.Box3().setFromCenterAndSize(
            position.clone().add(direction),
            new THREE.Vector3(1, playerHeight, 1)
        );

        for (const block of blocks) {
            const blockBounds = new THREE.Box3().setFromObject(block);
            if (blockBounds.intersectsBox(playerBounds)) {
                return blockBounds.max.y; // Возвращаем высоту столкновения
            }
        }
        return null; // Нет столкновений
    }

    // Управление движением
    function moveCamera(deltaTime) {
        const direction = new THREE.Vector3();
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();

        // Направления движения
        cameraWrapper.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        right.copy(forward).cross(new THREE.Vector3(0, 1, 0)).normalize();

        // Добавляем или вычитаем векторы для правильного направления
        if (movement.forward) direction.add(forward);
        if (movement.backward) direction.sub(forward);
        if (movement.left) direction.add(right);
        if (movement.right) direction.sub(right);

        direction.normalize().multiplyScalar(speed * deltaTime);

        // Проверяем на столкновения в горизонтальной плоскости
        const collisionHeight = checkCollisions(cameraWrapper.position, direction);
        if (collisionHeight === null || cameraWrapper.position.y > collisionHeight + 0.1) {
            cameraWrapper.position.add(direction);
        }

        // Гравитация
        if (!isGrounded) velocityY -= gravity * deltaTime;

        const nextYPosition = cameraWrapper.position.y + velocityY * deltaTime;
        const playerBounds = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(cameraWrapper.position.x, nextYPosition, cameraWrapper.position.z),
            new THREE.Vector3(1, playerHeight, 1)
        );

        let collisionDetected = false;

        for (const block of blocks) {
            const blockBounds = new THREE.Box3().setFromObject(block);
            if (blockBounds.intersectsBox(playerBounds)) {
                collisionDetected = true;
                if (velocityY < 0) {
                    isGrounded = true;
                    velocityY = 0;
                    cameraWrapper.position.y = blockBounds.max.y + playerHeight / 2; // Останавливаем над блоком
                }
                break;
            }
        }

        if (!collisionDetected) {
            isGrounded = nextYPosition <= playerHeight;
            cameraWrapper.position.y = Math.max(nextYPosition, playerHeight);
        }
    }

    // Управление клавишами
    document.addEventListener('keydown', (event) => {
        switch (event.code) {
            case 'KeyS': movement.forward = true; break;
            case 'KeyW': movement.backward = true; break;
            case 'KeyA': movement.left = true; break;
            case 'KeyD': movement.right = true; break;
            case 'Space':
                if (isGrounded) {
                    velocityY = jumpStrength;
                    isGrounded = false;
                }
                break;
        }
    });

    document.addEventListener('keyup', (event) => {
        switch (event.code) {
            case 'KeyS': movement.forward = false; break;
            case 'KeyW': movement.backward = false; break;
            case 'KeyA': movement.left = false; break;
            case 'KeyD': movement.right = false; break;
        }
    });

    // Блокировка мыши
    const instructions = document.getElementById('instructions');
    instructions.addEventListener('click', () => {
        document.body.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement === document.body) {
            instructions.style.display = 'none';
            document.addEventListener('mousemove', onMouseMove, false);
        } else {
            instructions.style.display = '';
            document.removeEventListener('mousemove', onMouseMove, false);
        }
    });

    // Управление камерой мышью
    // Управление камерой мышью
    let pitch = 0; // Угол наклона вверх/вниз
    let yaw = 0;   // Угол поворота влево/вправо

    function onMouseMove(event) {
        const sensitivity = 0.002;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        yaw -= movementX * sensitivity;
        pitch -= movementY * sensitivity;

        const maxPitch = Math.PI / 2;
        pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));

        cameraWrapper.rotation.y = yaw;
        camera.rotation.x = pitch;
    }

    // Анимация
    const clock = new THREE.Clock();

        // Массив для хранения пуль
    const bullets = [];

    // Функция создания пули
    function shootBullet() {
        const bulletGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const bulletMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Установить начальную позицию пули на позицию синего куба (оружия)
        const bulletPosition = new THREE.Vector3();
        weapon.getWorldPosition(bulletPosition); // Позиция синего куба
        bullet.position.copy(bulletPosition);

        // Направление движения пули
        const bulletDirection = new THREE.Vector3();
        camera.getWorldDirection(bulletDirection); // Направление камеры
        bullet.userData.velocity = bulletDirection.clone().multiplyScalar(10); // Скорость пули

        scene.add(bullet);
        bullets.push(bullet);
    }

    // Слушатель для нажатия левой кнопки мыши
    document.addEventListener('mousedown', (event) => {
        if (event.button === 0) { // Левая кнопка мыши
            shootBullet();
        }
    });

        // Функция обновления пуль
    // Функция обновления пуль с проверкой на столкновения
    function updateBullets(deltaTime) {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            const velocity = bullet.userData.velocity;

            // Обновить позицию пули
            bullet.position.add(velocity.clone().multiplyScalar(deltaTime));

            // Создаем границы пули
            const bulletBounds = new THREE.Box3().setFromObject(bullet);

            let isCollision = false;

            // Проверяем столкновение с каждым блоком
            for (const block of blocks) {
                const blockBounds = new THREE.Box3().setFromObject(block);

                if (bulletBounds.intersectsBox(blockBounds)) {
                    // Удаляем пулю и выходим из цикла
                    isCollision = true;
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    break;
                }
            }

            // Если пуля вышла за пределы сцены, удаляем её
            if (!isCollision && bullet.position.length() > 100) {
                scene.remove(bullet);
                bullets.splice(i, 1);
            }
        }
    }


    function animate() {
        const deltaTime = clock.getDelta();
        moveCamera(deltaTime);
        updateBullets(deltaTime); // Обновляем пули с проверкой столкновений
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    animate();
</script>

</body>
</html>
